from string import Template
from utils import get_json_obj
import json
from openai import OpenAI
from tqdm import tqdm

PROMPT = Template("""
I currently have several user queries in JSON format and corresponding methods to resolve these queries using Android intent actions. Hereâ€™s an example:
{
  "query": "Set an alarm at 4:30 PM on Thursdays for my online meeting.",
  "intent": "ACTION_SET_ALARM",
  "uri": "None",
  "mime": "",
  "extras": {
    "EXTRA_HOUR": 16,
    "EXTRA_MINUTES": 30,
    "EXTRA_MESSAGE": "Online Meeting",
    "EXTRA_DAYS": [
      5
    ],
    "EXTRA_RINGTONE": "None",
    "EXTRA_VIBRATE": false
  },
  "explanation": "This intent sets a recurring alarm for 4:30 PM every Thursday to remind the user about their online meeting."
}
I want to use GPT to generate the corresponding Intent and parameters based on user queries, and then compare the results and data to determine if the generated outputs are correct. However, it is not necessary for the parameters generated by GPT to match the answers exactly to be considered correct. For instance, in the example above, the user query does not mention whether vibration is needed; hence, for the EXTRA_VIBRATE field in extras, the generated result can differ from the answer, and this field type is ignore.
For the EXTRA_MESSAGE field, the user did not specify the content of the message explicitly; a generated result that semantically matches the answer is acceptable, and this field type is semantic.
For fields like EXTRA_HOUR and EXTRA_MINUTES, where the user query explicitly specifies the time, the generated result must exactly match the answer, and this field type is strict.

Next, I will provide you with an intent and a user query, and you need to output in the following format based on the example provided:
{
  "uri": {"type": "strict", "reason": "this intent uses no uri so the uri should be None"},
  "mime": {"type": "strict", "reason": "this intent uses no mime so the mime should be empty"},
  "extras": {
    "EXTRA_HOUR": {"type": "strict", "reason": "this intent requires a specific hour according to the user query"},
    "EXTRA_MINUTES": {"type": "strict", "reason": "this intent requires specific minutes according to the user query"},
    "EXTRA_MESSAGE": {"type": "semantic", "reason": "this intent requires a message according to the user query"},
    "EXTRA_DAYS": {"type": "strict", "reason": "user specifies Thursday as the day of the alarm, and 4 is the index of Thursday in the list of days"},
    "EXTRA_RINGTONE": {"type": "ignore", "reason": "user query does not mention ringtone"},
    "EXTRA_VIBRATE": {"type": "ignore", "reason": "user query does not mention vibrate"}
  }
}
Remember to strictly follow the format above for output, and do not output additional content.

Intent:
$intent

Data:
$data
""")

INTENT_FILE = "intents.jsonl"
INPUT_FILE = "filtered_data.jsonl"
OUTPUT_FILE = "annotation_data.jsonl"

if __name__ == "__main__":
    intent_info = {}
    
    with open(INTENT_FILE, "r") as fin:
        for line in fin:
            item = json.loads(line)
            intent_info[item["id"]] = item
    
    client = OpenAI()
    
    all_data = []
    with open(INPUT_FILE, "r") as fin:
        for line in fin:
            all_data.append(json.loads(line))
            
            
    with open(OUTPUT_FILE, "w") as fout:
        for item in tqdm(all_data):
            
            intent = intent_info[item["id"]]
            
            prompt = PROMPT.substitute(intent=json.dumps(intent, indent=2), data=json.dumps(item, indent=2))
            message = [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
            
            # print(f"message content: {message[0]['content']}")
            # break
            
            retry_num = 4
            while retry_num > 0:
                response = client.chat.completions.create(
                    messages=message,
                    model="gpt-4o-mini",
                    temperature=0.7,
                    max_tokens=4000,
                    top_p=1,
                )
                response_content = response.choices[0].message.content
                print(f"Response: {response_content}")
                res = json.loads(response_content)
                print(f"res: {res}")
                if not res:
                    print("Failed to parse response, retrying...")
                    retry_num -= 1
                else:
                    item["field_type"] = res
                    fout.write(json.dumps(item) + "\n")
                    fout.flush()
                    break
                
                
                
