{"name": "ACTION_CREATE_DOCUMENT", "description": "Creates a new document that app can write to. And user can select where they'd like to create it.\n\ninstead of selecting from existing PDF documents, \nthe ACTION_CREATE_DOCUMENT lets users select where they'd like to create a new document, such as within another app that manages the document's storage. \nAnd then return the URI location of document that you can write to.", "arguments": {"mime_type": {"description": "The MIME type of the document to be created (e.g., \"text/plain\", \"application/pdf\").", "type": "str", "required": true, "reason": "The MIME type must be an exact value as it strictly defines the document format; mismatch could lead to operation failures or wrong document type creation.", "match_type": "strict"}, "initial_name": {"description": "The suggested name for the new document.", "type": "str", "required": true, "reason": "Though the name can be subjective, it should be strictly matched to ensure the document is identified and accessed correctly by subsequent operations.", "match_type": "strict"}, "local_only": {"description": "If True, only allows creation in locations directly accessible on the device. \nDefaults to False.", "type": "bool", "required": false, "default": false, "reason": "This boolean value affects the location accessibility of the document creation and should correspond exactly to what the query specifies to ensure correct document storage.", "match_type": "strict"}}, "returns": {"description": "A URI as a string pointing to the newly created document.\nReturns None if the operation is cancelled or fails.", "type": "Optional[str]"}, "examples": ["# Create a new text document\nnew_doc_uri = ACTION_CREATE_DOCUMENT(\"text/plain\", \"New Document.txt\")\n\n# Create a new PDF file\nnew_pdf_uri = ACTION_CREATE_DOCUMENT(\"application/pdf\", \"Report.pdf\")\n\n# Create a new local image file\nnew_image_uri = ACTION_CREATE_DOCUMENT(\"image/jpeg\", \"Photo.jpg\", local_only=True)"]}
{"name": "ACTION_EDIT_CONTACT", "description": "Edit an existing contact.\n\nThis function allows the user to edit the details of a specific contact\nbased on the provided contact URI. Additional contact information can be\nprovided to pre-fill certain fields in the edit form.\nNote:\n    The contact_uri can be obtained in two primary ways:\n    1. Using the contact URI returned by the ACTION_PICK function.\n    2. Accessing the list of all contacts directly (requires appropriate permissions).", "arguments": {"contact_uri": {"description": "A content URI as a string, pointing to the contact\nto be edited. This URI can be obtained from the ACTION_PICK function\nor by querying the contacts database.", "type": "str", "required": true, "reason": "The URI is a unique identifier and needs to be exactly the same as specified to correctly identify the contact. Thus, it should be strictly matched.", "match_type": "strict"}, "contact_info": {"description": "A dictionary containing additional\ncontact information to pre-fill in the edit form. Keys should correspond\nto contact fields (available key: 'email', 'phone', 'name', 'company', 'address'), and values should be\nthe data to pre-fill. Default is None.", "type": "Optional[Dict[str, Any]]", "required": false, "default": null, "reason": "This dictionary contains additional information that can vary and does not need to be exactly the same, only the types and structure should conform. It should be semantically matched.", "match_type": "semantic"}}}
{"name": "ACTION_GET_CONTENT", "description": "Simulates the ACTION_GET_CONTENT intent to retrieve file(s) of a specific type.\n\nThis function allows the user to select one or more files of a specified MIME type.\nIt returns a list of content URIs for the selected file(s).", "arguments": {"mime_type": {"description": "The MIME type of the file(s) to be selected (e.g., \"image/*\", \"audio/*\", \"video/*\", \"*/*\").", "type": "str", "required": true, "reason": "MIME type would be typically specified explicitly in the input by the user and should match exactly as required by the function criteria.", "match_type": "strict"}, "allow_multiple": {"description": "If True, allows selection of multiple files. Defaults to False.", "type": "bool", "required": false, "default": false, "reason": "This is a boolean flag that enables or disables a feature, thus requiring a strict match to function correctly based on user input.", "match_type": "strict"}, "local_only": {"description": "If True, only returns files that are directly available on the device. Defaults to False.", "type": "bool", "required": false, "default": false, "reason": "As a boolean parameter that determines the scope of file accessibility, it is essential that this matches strictly what the user specifies for accurate functionality.", "match_type": "strict"}, "openable_only": {"description": "If True, only returns files that can be opened as a file stream. Defaults to False.", "type": "bool", "required": false, "default": false, "reason": "Being a functional directive that significantly affects the output (i.e., whether the file can be opened), this requires strict adherence to the user's input.", "match_type": "strict"}}, "returns": {"description": "A list of URIs as strings, each pointing to a selected file.\nIf no file is selected or the operation is cancelled, returns an empty list.", "type": "List[str]"}, "examples": ["# Select a single image\nimage_uris = ACTION_GET_CONTENT(\"image/*\")\n\n# Select multiple documents\ndoc_uris = ACTION_GET_CONTENT(\"application/pdf\", allow_multiple=True)\n\n# Select a local audio file that can be opened as a stream\naudio_uris = ACTION_GET_CONTENT(\"audio/*\", local_only=True, openable_only=True)"]}
{"name": "ACTION_IMAGE_CAPTURE", "description": "Capture a picture using the camera app and return the URI of the saved photo.\n\nThis function uses the ACTION_IMAGE_CAPTURE intent to open the camera app and capture a photo.\nThe photo is saved to a URI location, which is returned by this function.\nUser can then use this URI to access the photo file and do whatever they want with it.", "arguments": {}, "returns": {"description": "The URI location where the camera app saves the photo file.", "type": "str"}}
{"name": "ACTION_INSERT_CONTACT", "description": "Insert a new contact.\n\nThis function allows the user to create a new contact with the provided\ncontact information. It will open the contact creation interface with\npre-filled information based on the provided data.", "arguments": {"contact_info": {"description": "A dictionary containing the contact\ninformation to pre-fill in the new contact form. Keys should\ncorrespond to contact fields (available key: 'email', 'phone', 'name', 'company', 'address'),\nand values should be the data to pre-fill.", "type": "Dict[str, Any]", "required": true, "reason": "As this includes pre-filled data that must appear directly in the created contact, all keys such as 'email', 'phone', 'name', 'company', and 'address' should be strictly matched.", "match_type": "strict"}}, "examples": ["ACTION_INSERT({\n    \"name\": \"John Doe\",\n    \"email\": \"john.doe@example.com\",\n    \"phone\": \"1234567890\"\n})"]}
{"name": "ACTION_INSERT_EVENT", "description": "Add a new event to the user's calendar.\n", "arguments": {"TITLE": {"description": "The event title.", "type": "str", "required": true, "reason": "The title of the event, while specific, can vary in its phrasing while conveying the same meaning, hence should be semantically matched.", "match_type": "semantic"}, "DESCRIPTION": {"description": "The event description.", "type": "str", "required": true, "reason": "The description offers details about the event and can vary widely while still being accurate, therefore it should be semantically matched.", "match_type": "semantic"}, "EVENT_LOCATION": {"description": "The event location.", "type": "str", "required": true, "reason": "The location of an event is a critical, exact detail that should precisely match the data provided, hence it should be strictly matched.", "match_type": "strict"}, "EXTRA_EVENT_ALL_DAY": {"description": "A boolean specifying whether this is an all-day event. Default is False.", "type": "bool", "required": false, "default": false, "reason": "This boolean field represents a specific characteristic of the event which does not lend itself to interpretation, thus it should be strictly matched.", "match_type": "strict"}, "EXTRA_EVENT_BEGIN_TIME": {"description": "The start time of the event in ISO 8601 format. Default is None.", "type": "str", "required": false, "default": null, "reason": "The start time is a specific point that should match exactly as event scheduling depends on this accuracy, thus it should be strictly matched.", "match_type": "strict"}, "EXTRA_EVENT_END_TIME": {"description": "The end time of the event in ISO 8601 format. Default is None.", "type": "str", "required": false, "default": null, "reason": "Similar to the start time, the end time needs to be exact as it affects the event schedule, therefore should be strictly matched.", "match_type": "strict"}, "EXTRA_EMAIL": {"description": "A list of email addresses that specify the invitees. Default is None.", "type": "List[str]", "required": false, "default": null, "reason": "Email addresses are specific identifiers that should match exactly to ensure correct notification and invitation handling, thus should be strictly matched.", "match_type": "strict"}}}
{"name": "ACTION_OPEN_DOCUMENT", "description": "Opens a file or multiple files of specified MIME type(s).\n\nThis function allows the user to select one or more files of specified MIME type(s).\nIt provides long-term, persistent access to the selected file(s). This is usually better than using ACTION_GET_CONTENT, since it can also access files from cloud storage or other document providers.", "arguments": {"mime_types": {"description": "The MIME type(s) of the file(s) to be selected.\nCan be a list of strings for multiple types or only a list with a single string for a single type.", "type": "List[str]", "required": true, "reason": "MIME types need to be exactly as specified to ensure the correct types of files are selectable.", "match_type": "strict"}, "allow_multiple": {"description": "If True, allows selection of multiple files. Defaults to False.", "type": "bool", "required": false, "default": false, "reason": "The boolean nature of this field demands a strict match as it influences the fundamental operation (single vs multiple file selection).", "match_type": "strict"}, "local_only": {"description": "If True, only returns files that are directly available on the device. Defaults to False.", "type": "bool", "required": false, "default": false, "reason": "Since this field specifies whether only local files can be accessed, it needs to be strictly matched.", "match_type": "strict"}}, "returns": {"description": "A list of content URIs as strings, each pointing to a selected file.\nIf no file is selected or the operation is cancelled, returns an empty list.", "type": "List[str]"}, "examples": ["# Open a single image\nimage_uris = ACTION_OPEN_DOCUMENT(\"image/*\")\n\n# Open multiple documents of different types\ndoc_uris = ACTION_OPEN_DOCUMENT([\"application/pdf\", \"text/plain\"], allow_multiple=True)\n\n# Open a local audio file\naudio_uris = ACTION_OPEN_DOCUMENT(\"audio/*\", local_only=True)"]}
{"name": "ACTION_PICK", "description": "This function allows the user to select a contact or specific contact information (such as phone\nnumber, email, or postal address) and returns a content URI for the selected data.", "arguments": {"data_type": {"description": "The type of contact data to pick. Default is \"ALL\".\nAvailable options:\n- \"ALL\": Pick a full contact\n- \"PHONE\": Pick a contact's phone number\n- \"EMAIL\": Pick a contact's email address\n- \"POSTAL\": Pick a contact's postal address", "type": "str", "required": false, "default": "ALL", "reason": "Since the type of data to be picked is specified by the user's choice and it impacts the resultant data directly, it should be strictly matched with the given solution.", "match_type": "strict"}}, "returns": {"description": "A content URI as a string, pointing to the selected contact or contact data.\nThis URI can be used to query for more details about the contact.", "type": "str"}}
{"name": "ACTION_SET_ALARM", "description": "Set an alarm with the given parameters.\n", "arguments": {"EXTRA_HOUR": {"description": "The hour of the alarm in 24-hour format.", "type": "int", "required": true, "reason": "The hour of the alarm is fixed and specific, so it should be strictly matched.", "match_type": "strict"}, "EXTRA_MINUTES": {"description": "The minutes of the alarm.", "type": "int", "required": true, "reason": "The minutes of the alarm are fixed and specific, so it should be strictly matched.", "match_type": "strict"}, "EXTRA_MESSAGE": {"description": "The message of the alarm. Default is an empty string.", "type": "str", "required": false, "default": "", "reason": "The message of the alarm can vary in wording but should convey a specific intent or information semantically.", "match_type": "semantic"}, "EXTRA_DAYS": {"description": "The days of the alarm, e.g. [\"Monday\", \"Tuesday\"]. Default is None.", "type": "list[str]", "required": false, "default": null, "reason": "Days are specific but often subject to variation if the context implies flexibility in days of alarm (e.g., weekdays vs. weekends), thus should be semantically matched.", "match_type": "semantic"}, "EXTRA_RINGTONE": {"description": "The ringtone of the alarm specified by a content URI. Default is None.\nif None, the default ringtone will be used. If set to \"silent\", no ringtone will be played.\n        ", "type": "str", "required": false, "default": null, "reason": "Ringtones, while may be specified, can have different formats or sources that achieve the same purpose, thus should be semantically matched unless explicitly specified.", "match_type": "semantic"}, "EXTRA_VIBRATE": {"description": "Whether the alarm should vibrate. Default is False.", "type": "bool", "required": false, "default": false, "reason": "This is a specific functionality that either is activated or isn't, so it should be strictly matched.", "match_type": "strict"}, "EXTRA_SKIP_UI": {"description": "A boolean specifying whether the responding app must skip its UI when setting the alarm.\nIf true, the app must bypass any confirmation UI and set the specified alarm. Default is True.", "type": "bool", "required": false, "default": true, "reason": "This is a functionality setting that requires a true or false only, strictly adhering to the provided specification.", "match_type": "strict"}}}
{"name": "ACTION_SET_TIMER", "description": "Set a countdown timer with the given parameters.\n", "arguments": {"EXTRA_LENGTH": {"description": "The length of the timer in seconds.", "type": "int", "required": true, "reason": "The length of the timer is a specific configuration that determines the function of the timer, so it should be strictly matched.", "match_type": "strict"}, "EXTRA_MESSAGE": {"description": "A custom message to identify the timer. Default is an empty string.", "type": "str", "required": false, "default": "", "reason": "The message is subjective and can vary widely; therefore it should be semantically matched.", "match_type": "semantic"}, "EXTRA_SKIP_UI": {"description": "A boolean specifying whether the responding app must skip its UI when setting the timer.\nIf true, the app must bypass any confirmation UI and start the specified timer. Default is True.", "type": "bool", "required": false, "default": true, "reason": "This is a boolean flag that alters the behavior of the timer setup significantly, requiring strict adherence to the specified value.", "match_type": "strict"}}}
{"name": "ACTION_SHOW_ALARMS", "description": "Show the list of current alarms.", "arguments": {}}
{"name": "ACTION_VIDEO_CAPTURE", "description": "Capture a video using the camera app and return the URI of the saved video.\n\nThis function uses the ACTION_VIDEO_CAPTURE intent to open the camera app and capture a video.\nThe video is saved to a URI location, which is returned by this function.\nUser can then use this URI to access the video file and do whatever they want with it.", "arguments": {}, "returns": {"description": "The URI location where the camera app saves the video file.", "type": "str"}}
{"name": "ACTION_VIEW_CONTACT", "description": "Display the details for a known contact.\n\nThis function allows the user to view the details of a specific contact\nbased on the provided contact URI.", "arguments": {"contact_uri": {"description": "A content URI as a string, pointing to the contact\nwhose details should be displayed. This URI can be obtained from\nthe ACTION_PICK function or by querying the contacts database.", "type": "str", "required": true, "reason": "The URI needs to be exactly correct to retrieve the right contact information, thus it should be strictly matched.", "match_type": "strict"}}}
{"name": "CALL_CAR", "description": "Help use to open a app that can be used to call a car.", "arguments": {}}
{"name": "INTENT_ACTION_STILL_IMAGE_CAMERA", "description": "Open a camera app in still image mode for capturing photos for user.", "arguments": {}}
{"name": "INTENT_ACTION_VIDEO_CAMERA", "description": "Open a camera app in video mode to start recording a video.", "arguments": {}}
{"name": "create_note", "description": "Generates an intent URI to create a new note.\n\nThis function can create a note using a note app in Android, allowing the creation\nof a new note with a subject and text content. It's designed to be used with note-taking\napplications.", "arguments": {"subject": {"description": "The title or subject of the note.", "type": "str", "required": true, "reason": "It is the title or subject of the note, often varying widely in nature, so it should be semantically matched.", "match_type": "semantic"}, "text": {"description": "The main content or body of the note.", "type": "str", "required": true, "reason": "The content of the note can be subjective and may vary, so it should be semantically matched.", "match_type": "semantic"}, "mime_type": {"description": "The MIME type of the note content. Defaults to \"text/plain\".\nUse \"*/*\" for generic content type.", "type": "Optional[str]", "required": false, "default": "text/plain", "reason": "MIME type specifies the format of the note, this should be strictly matched as different types can affect the way the content is processed and displayed.", "match_type": "strict"}}, "examples": ["# Create a simple text note\nintent_uri = create_note(\"Shopping List\", \"Milk, Eggs, Bread\")\n\n# Create a note with a different MIME type\nintent_uri = create_note(\"Meeting Minutes\", \"<html><body><h1>Team Meeting</h1></body></html>\", \"text/html\")"]}
{"name": "dial", "description": "Initiates a phone call or opens the dialer with a specified number in a phone app for user.\n\nThis function allows you to start a phone call process. It can either open\nthe dialer with a pre-filled number or directly initiate a call, depending\non the parameters provided.", "arguments": {"phone_number": {"description": "The phone number to dial. This should be a valid\ntelephone number as defined in IETF RFC 3966. Examples include:\n\"2125551212\" or \"(212) 555 1212\".", "type": "str", "required": true, "reason": "The phone number should exactly match the input for accuracy in dialing.", "match_type": "strict"}, "direct_call": {"description": "If True, attempts to start the call directly\nwithout user intervention. If False (default), opens the dialer with\nthe number pre-filled, requiring user action to start the call.", "type": "bool", "required": false, "default": false, "reason": "This is a binary option that must be strictly matched to function correctly in the intended manner.", "match_type": "strict"}, "use_voicemail": {"description": "If True, attempts to call the voicemail\nfor the specified number. Defaults to False.", "type": "bool", "required": false, "default": false, "reason": "This parameter controls a specific function and should be strictly matched to ensure the correct behavior.", "match_type": "strict"}}, "examples": ["# Open dialer with a number\ndial(\"2125551212\")\n\n# Attempt to call a number directly\ndial(\"(212) 555 1212\", direct_call=True)\n\n# Call voicemail\ndial(\"2125551212\", use_voicemail=True)"]}
{"name": "open_settings", "description": "Opens a specific settings screen on the device.\n\nThis function allows you to open various system settings screens,\nproviding quick access to different device configuration options.", "arguments": {"setting_type": {"description": "The type of settings screen to open.\nPossible values are:\n- \"general\": General settings (default)\n- \"wireless\": Wireless & network settings\n- \"airplane_mode\": Airplane mode settings\n- \"wifi\": Wi-Fi settings\n- \"apn\": APN settings\n- \"bluetooth\": Bluetooth settings\n- \"date\": Date & time settings\n- \"locale\": Language & input settings\n- \"input_method\": Input method settings\n- \"display\": Display settings\n- \"security\": Security settings\n- \"location\": Location settings\n- \"internal_storage\": Internal storage settings\n- \"memory_card\": Memory card settings", "type": "SettingType", "required": false, "default": "general", "reason": "The specific setting type parameter matches one of a set predefined values, so it should be strictly matched.", "match_type": "strict"}}, "examples": ["# Open general settings\nopen_settings()\n\n# Open Wi-Fi settings\nopen_settings(\"wifi\")\n\n# Open Bluetooth settings\nopen_settings(\"bluetooth\")"]}
{"name": "play_media", "description": "User can use this function to play a media file (audio or video) using an URI that specifies the location of the media file.\n", "arguments": {"uri": {"description": "The URI of the media file. Supported schemes: file, content, http.", "type": "str", "required": true, "reason": "The URI specifies the exact location of the media file and thus should match exactly as provided in the query.", "match_type": "strict"}, "mime_type": {"description": "The MIME type of the media file. If not provided,\nthe function will attempt to guess it based on the file extension.", "type": "Optional[str]", "required": false, "default": null, "reason": "The MIME type is optional and can vary or be omitted, allowing for flexible handling, but when specified in a query, it should be matched strictly.", "match_type": "strict"}}, "examples": ["# Play a local audio file\nintent_uri = play_media(\"file:///storage/emulated/0/Music/song.mp3\")\n\n# Play a remote video file with a specified MIME type\nintent_uri = play_media(\"http://example.com/video.mp4\", \"video/mp4\")\n\n# Play a content URI audio file\nintent_uri = play_media(\"content://media/external/audio/media/1234\")"]}
{"name": "play_music_from_search", "description": "Generates an intent URI to play music based on a search query.\n\nThis function creates an intent URI that simulates the INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH\naction in Android. It allows playing music based on various search criteria such as\nartist, album, song, genre, or playlist.\n\nArgs:\n    query (str): The main search query. For 'any' focus, this should be an empty string.\n    focus (Literal[\"any\", \"unstructured\", \"genre\", \"artist\", \"album\", \"song\", \"playlist\"]):\n        The search mode, indicating what type of content to focus on.\n    artist (Optional[str]): The name of the artist to search for.\n    album (Optional[str]): The name of the album to search for.\n    title (Optional[str]): The title of the song to search for.\n    genre (Optional[str]): The genre of music to search for.\n    playlist (Optional[str]): The name of the playlist to search for.\n    Notes:\n    - The 'query' parameter is always required for backward compatibility.\n    - Different focus modes may require specific parameters:\n      * 'any': No additional parameters required.\n      * 'unstructured': No additional parameters required.\n      * 'genre': 'genre' parameter is required.\n      * 'artist': 'artist' parameter is required.\n      * 'album': 'album' parameter is required.\n      * 'song': 'title' parameter is required.\n      * 'playlist': 'playlist' parameter is required.\n\nRaises:\n    ValueError: If the provided focus is invalid or if required parameters for a specific focus are missing.\n\nExamples:\n    # Play any music\n    intent_uri = play_music_from_search(\"\", \"any\")\n\n    # Play music by a specific artist\n    intent_uri = play_music_from_search(\"Michael Jackson\", \"artist\", artist=\"Michael Jackson\")\n\n    # Play a specific song\n    intent_uri = play_music_from_search(\"Billie Jean\", \"song\", title=\"Billie Jean\", artist=\"Michael Jackson\")\n\n    # Play music from a genre\n    intent_uri = play_music_from_search(\"Rock\", \"genre\", genre=\"Rock\")\n\n    # Play a specific album\n    intent_uri = play_music_from_search(\"Thriller\", \"album\", album=\"Thriller\", artist=\"Michael Jackson\")\n\n    # Play a playlist\n    intent_uri = play_music_from_search(\"My Favorites\", \"playlist\", playlist=\"My Favorites\")", "arguments": {}}
{"name": "search_location", "description": "Search for a location using a query string in a map application for user.\n", "arguments": {"query": {"description": "The search query string to find a location.", "type": "str", "required": true, "reason": "The search query is usually unique and should match exactly to ensure the correct location is found.", "match_type": "strict"}}}
{"name": "send_email", "description": "Compose and send an email with optional attachments.\n\nThis function allows the user to compose an email with various options,\nincluding multiple recipients, CC, BCC, and file attachments.", "arguments": {"to": {"description": "A list of recipient email addresses.", "type": "List[str]", "required": true, "reason": "Recipient email addresses need to be strictly matched as they determine the direct receivers of the email.", "match_type": "strict"}, "subject": {"description": "The subject of the email.", "type": "str", "required": true, "reason": "The subject of an email should be strictly matched as it directly reflects the content and purpose of the communication.", "match_type": "strict"}, "body": {"description": "The body text of the email.", "type": "str", "required": true, "reason": "The body of the email can be evaluated semantically because different wordings can express the same intentions or information.", "match_type": "semantic"}, "cc": {"description": "A list of CC recipient email addresses. Default is None.", "type": "Optional[List[str]]", "required": false, "default": null, "reason": "CC recipient email addresses should be strictly matched as they also determine who receives the email, affecting the distribution of information.", "match_type": "strict"}, "bcc": {"description": "A list of BCC recipient email addresses. Default is None.", "type": "Optional[List[str]]", "required": false, "default": null, "reason": "BCC recipient email addresses should be strictly matched since they define the recipients who receive the email without other recipients' knowledge.", "match_type": "strict"}, "attachments List[str]": {"description": "list of URIs\npointing to the files to be attached to the email. These can be file URIs,\ncontent URIs, or any other valid Android resource URI. Default is None (meaning no attachments). ", "type": null, "required": false}}, "examples": ["# Send an email with a content URI attachment\nsend_email(\n    to=[\"recipient@example.com\"],\n    subject=\"Document\",\n    body=\"Please find the attached document.\",\n    attachments=[\"content://com.android.providers.downloads.documents/document/1234\"]\n)\n\n# Send an email with multiple attachments using different URI types\nsend_email(\n    to=[\"team@example.com\"],\n    subject=\"Project Files\",\n    body=\"Here are the latest project files.\",\n    attachments=[\n        \"content://media/external/images/media/5678\",\n        \"content://com.android.externalstorage.documents/document/primary%3ADownload%2Freport.pdf\"\n    ]\n)"]}
{"name": "show_location", "description": "Show a location on a map with the given latitude and longitude coordinates.\n", "arguments": {"latitude": {"description": "The latitude of the location to be shown.", "type": "float", "required": true, "reason": "Latitude is a fundamental geographic coordinate defining a specific location and should be strictly matched.", "match_type": "strict"}, "longitude": {"description": "The longitude of the location to be shown.", "type": "float", "required": true, "reason": "Longitude is a fundamental geographic coordinate defining a specific location and should be strictly matched.", "match_type": "strict"}, "zoom": {"description": "The zoom level of the map. The highest (closest) zoom level is 23.\nA zoom level of 1 shows the whole Earth, centered at the given lat,lng. \nZoom level in mapping refers to the level of detail or magnification at which a map is displayed. It's a fundamental concept in digital mapping and determines how much of the Earth's surface is visible and how much detail is shown on the map. ", "type": "int", "required": false, "default": 15, "reason": "Zoom level affects map detail and view, but varying it might depend on specific implementation needs, thus a semantic match could suffice.", "match_type": "semantic"}}}
{"name": "web_search", "description": "Initiates a web search using the specified query.\n\nThis function starts a web search using the default search engine or a specified one.\nIt opens the search results in the default web browser or appropriate search application.", "arguments": {"query": {"description": "The search string or keywords to be used for the web search.", "type": "str", "required": true, "reason": "The search keywords or string is expected to be semantically correct to perform an effective search but doesn't require a strict match to a previous or specific term since search terms can vary widely.", "match_type": "semantic"}, "search_engine": {"description": "The name or URL of a specific search engine to use.\nIf None, the default search engine will be used.", "type": "Optional[str]", "required": false, "default": null, "reason": "The name of the search engine should either match a predefined list or conform to a recognized URL format; a strict match is not always necessary unless a specific engine is required for testing or functionality.", "match_type": "strict"}}, "examples": ["# Perform a simple web search\nweb_search(\"Python programming tutorials\")\n\n# Search using a specific search engine\nweb_search(\"climate change\", search_engine=\"ecosia\")\n\n# Search for a phrase\nweb_search('\"to be or not to be\"')"]}
