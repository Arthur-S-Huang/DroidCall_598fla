from string import Template
import json
import random
from typing import Generator, Iterable
from utils import extract_and_parse_jsons
from openai import OpenAI


PROMPT = Template("""
I want to collect some user queries and their corresponding solutions using Android intents. GPT has generated some data for me, but these data still have issues. I'd like you to help me filter out the correct and usable data. I'll now tell you what problems might exist in the data.

The sample Android intent description used is:
{"action": "ACTION_SET_ALARM", "uri": "None", "mime": {}, "extras": {"EXTRA_HOUR": "The hour for the alarm.", "EXTRA_MINUTES": "The minutes for the alarm.", "EXTRA_MESSAGE": "A custom message to identify the alarm.", "EXTRA_DAYS": "An ArrayList including each week day on which this alarm\n repeats. Each day must be declared with an integer from the Calendar\n class, such as MONDAY.\n For a one-time alarm, don't specify this extra.", "EXTRA_RINGTONE": "A content: URI specifying a ringtone to use with the alarm, or VALUE_RINGTONE_SILENT for no ringtone.\n To use the default ringtone, don't specify this extra.", "EXTRA_VIBRATE": "A boolean specifying whether to vibrate for this alarm.", "EXTRA_SKIP_UI": "A boolean specifying whether the responding app must skip its UI when setting the alarm.\n If true, the app must bypass any confirmation UI and set the specified alarm."}, "desc": "The following are common actions for alarm clock apps, including the information you need\nto create an intent filter to advertise your app's ability to perform each action.\nTo create a new alarm, use the ACTION_SET_ALARM action and specify alarm details such as the time and message using the following extras.\nNote: Only the hour, minutes, and message extras are available in Android 2.3 (API level 9) and lower. The other extras are available in higher versions of the platform.\n", "id": 1}

Below is a user query and its corresponding solution generated by GPT:
{"query": "Set an alarm for 9:30 AM with a specific alarm tone so I wake up for my job interview.", "intent": "ACTION_SET_ALARM", "uri": "None", "mime": {}, "extras": {"EXTRA_HOUR": 9, "EXTRA_MINUTES": 30, "EXTRA_MESSAGE": "Job Interview", "EXTRA_DAYS": [], "EXTRA_RINGTONE": "content://media/internal/audio/media/45", "EXTRA_VIBRATE": true}, "explanation": "This intent sets a one-time alarm for 9:30 AM that uses a specific ringtone to alert the user for their job interview.", "id": 1}

As you can see, the user query in this generated data doesn't provide enough information. The specific alarm tone mentioned by the user isn't given, and the subsequent EXTRA_RINGTONE is arbitrarily invented by GPT, not matching the user's intent. Therefore, this data is not usable.

Another example uses this intent:
{"action": "ACTION_IMAGE_CAPTURE", "uri": "None", "mime": {}, "extras": {"EXTRA_OUTPUT": "The URI location where the camera app saves the photo or\n video file (as a Uri object)."}, "desc": "The following are common actions for camera apps, including the information you need\nto create an intent filter to advertise your app's ability to perform each action.\nTo open a camera app and receive the resulting photo or video, use the ACTION_IMAGE_CAPTURE or ACTION_VIDEO_CAPTURE action. Also specify the URI location where you'd like the camera to save the photo or video, in the EXTRA_OUTPUT extra.\n", "id": 5}

The corresponding data is:
{"query": "Can I take a picture of my cat and automatically categorize it as a pet photo?", "intent": "ACTION_IMAGE_CAPTURE", "mime": "", "uri": "content://myapp/pets/cat_photo.jpg", "extras": {"EXTRA_OUTPUT": "content://myapp/pets/cat_photo.jpg"}, "explanation": "The intent enables you to capture an image of your cat and save it to a specific URI designated for pet photos.", "id": 5}

This data also has issues. The user didn't specify a particular app, so the URI in the intent is arbitrarily invented. Thus, this data is also not usable.

Many of the data I've received may have similar problems, where unclear queries lead to inability to provide specific intent actions and corresponding extras to solve the user's problem. 
I'd like you to help me filter out the data that meets the requirements. While checking the data, you should carefully check each field of the solution. Whether the field is reasonable
according to the user query? Can this field be inferred based on the user's request? If it is not, the data should be filtered out.

Now, I'll give you intent information and some data. Please generate output in the form of {"qualified": true or false, "reason": ..., "id": ...(should match with the data id)}, where 'qualified' indicates whether the data is usable. If the data is usable, i.e., there are no problems with the query and solution, this field should be true; otherwise, false. 'Reason' explains the reason for the 'qualified' field. 'id' should correspond to the id in the data I give you. Remember to strictly follow the format I've given and don't output any other content.

I'll now provide one piece of intent information and several corresponding data points. Please generate output for these data.

intent:

$intent

data:

$data
""")

INPUT_FILE = "machine_generated.jsonl"
INTENT_FILE = "intents.jsonl"
OUTPUT_FILE = "filtered_data.jsonl"
BATCH_SIZE = 10
DATA_NUM_PER_ID = 2

class Filter:
        
    def filter(self, data: Iterable[dict])->Generator[dict, None, None]:
        pass
    

class LLMFilter(Filter):
    """
    Filter data of a specific intent using a language model.
    """
    def __init__(self, model_name="gpt-4o-mini", temperature=0.7, top_p=1, max_tokens=4000) -> None:
        super().__init__()
        self.client = OpenAI()
        self.model_name = model_name
        self.temperature = temperature
        self.top_p = top_p
        self.max_tokens = max_tokens
    
    def set_data(self, intent: dict):
        self.intent_text = json.dumps(intent, indent=2)
        self.id = intent["id"]
    
    def filter(self, data: Iterable[dict]) -> Generator[dict, None, None]:
        data_text = ""
        data_dict = {}
        for id, item in enumerate(data):
            item["id"] = id
            data_dict[id] = item
            data_text += json.dumps(item, indent=2) + "\n"
            
            message = [
                {
                    "role": "user",
                    "content": PROMPT.substitute(intent=self.intent_text, data=data_text)
                }
            ]
        
        # print(f"message content: {message[0]['content']}")
        
        response = self.client.chat.completions.create(
            messages=message,
            model=self.model_name,
            temperature=self.temperature,
            max_tokens=self.max_tokens,
            top_p=self.top_p,
        )
        
        
        for filtered_item in extract_and_parse_jsons(response.choices[0].message.content):
            filtered_id = filtered_item["id"]
            if filtered_item["qualified"]:
                data_dict[filtered_id]['id'] = self.id
                yield data_dict[filtered_id]
            else:
                print(f"Data:\n {json.dumps(data_dict[filtered_id], indent=2)} \n is not qualified: {filtered_item['reason']}")
        

if __name__ == "__main__":
    all_data = {}
    with open(INPUT_FILE, "r") as fin:
        for line in fin:
            item = json.loads(line)
            if item["id"] not in all_data:
                all_data[item["id"]] = []
            all_data[item["id"]].append(item)
            
    intent_info = {}
    with open("intents.jsonl", "r") as fin:
        for line in fin:
            item = json.loads(line)
            intent_info[item["id"]] = item
        
    filter = LLMFilter()
            
    ids = list(all_data.keys())
    fout = open(OUTPUT_FILE, "w")
    
    for id in ids:
        data = all_data[id]
        random.shuffle(data)
        idx = 0
        num_filtered = 0
        while num_filtered  < DATA_NUM_PER_ID and idx < len(data):
            batch = data[idx:idx + BATCH_SIZE]
            idx += BATCH_SIZE
            
            # filter data till the number of data is enough
            filter.set_data(intent_info[id])
            for item in filter.filter(batch):
                fout.write(json.dumps(item) + "\n")
                num_filtered += 1
                if num_filtered >= DATA_NUM_PER_ID:
                    break
            
            fout.flush()
                
    fout.close()
